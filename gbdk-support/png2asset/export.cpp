// This prevents windows build errors regarding the 'fopen' function
// Example: 'fopen': This function or variable may be unsafe.Consider using fopen_s instead.To disable deprecation, use _CRT_SECURE_NO_WARNINGS.See online help for details.
// More info: https://stackoverflow.com/questions/14386/fopen-deprecated-warning
// From bbbbbr: `Looks like some of the benefits are concurrency protection, but that probably isn't an issue for png2asset`
#ifdef _WIN32
#define _CRT_SECURE_NO_DEPRECATE
#endif

#include <vector>
#include <string>
#include <algorithm>
#include <cstring>
#include <set>
#include <stdio.h>
#include <fstream>
#include <cstdint>

#include "lodepng.h"
#include "mttile.h"

#include "cmp_int_color.h"
#include "metasprites.h"

#include "png2asset.h"
#include "png_image.h"
#include "export.h"
#include "image_utils.h"
#include "process_arguments.h"
#include "rgb_to_nes_lut.h"

using namespace std;

size_t export_color_count, export_color_start;
size_t export_tiles_count, export_tiles_start;
bool use_structs_with_source_tileset;
bool has_palette_data_to_export;


string extract_name(string const & name)
{
    int p = name.find_last_of("/\\");
    string res = (p > 0) ? name.substr(p + 1) : name;
    p = name.find_first_of(".");
    return (p > 0) ? res.substr(0, p) : res;
}


// Calculate some shared export settings (.c, .h, binary)
// This gets called at the start of each export output function
static void calc_palette_and_tileset_export_size(PNG2AssetData* assetData) {

    use_structs_with_source_tileset = (assetData->args->has_source_tilesets == true) && (assetData->args->use_structs == true);

    // (source_tileset + use_structs is a special combination for ZGB
    if (use_structs_with_source_tileset) {
        // Export all colors and tiles, including those from source tileset
        export_color_start = 0;
        export_color_count = (unsigned int)assetData->image.total_color_count;
        export_tiles_start = 0;
        export_tiles_count = assetData->tiles.size();
    } else {
        // Otherwise default behavior is to skip past/offset however many
        // palettes and tiles were present in the source tileset
        export_color_start = assetData->args->source_total_color_count;
        export_color_count = assetData->image.total_color_count - assetData->args->source_total_color_count;
        export_tiles_start = assetData->args->source_tileset_size;
        export_tiles_count = assetData->tiles.size() - assetData->args->source_tileset_size;
    }

    // When to export palette data:
    //   - Not using a source tileset                        : include all colors
    //   - Using a source tileset and there are extra colors : include only colors not present in source tileset
    //   - Using a source tileset + zgb's use_structs mode   : include all source tileset and colors not present in source tileset
    //
    //   AND it's not turned off via include_palettes = false
    has_palette_data_to_export = (assetData->args->include_palettes &
                                  ((assetData->args->has_source_tilesets == false) || (export_color_count > 0) || (use_structs_with_source_tileset == true)));
}


bool export_h_file( PNG2AssetData* assetData) {

    FILE* file;
    calc_palette_and_tileset_export_size(assetData);

    file = fopen(assetData->args->output_filename_h.c_str(), "w");
    if(!file) {
        printf("Error writing file: %s", assetData->args->output_filename_h.c_str());
        return false;
    }

    fprintf(file, "//AUTOGENERATED FILE FROM png2asset\n");
    fprintf(file, "#ifndef METASPRITE_%s_H\n", assetData->args->data_name.c_str());
    fprintf(file, "#define METASPRITE_%s_H\n", assetData->args->data_name.c_str());
    fprintf(file, "\n");
    fprintf(file, "#include <stdint.h>\n");
    fprintf(file, "#include <gbdk/platform.h>\n");
    fprintf(file, "#include <gbdk/metasprites.h>\n");
    fprintf(file, "\n");
    if(assetData->args->use_structs)
    {
        if(assetData->args->export_as_map)
        {
            fprintf(file, "#include \"TilesInfo.h\"\n");
            fprintf(file, "#include \"MapInfo.h\"\n");
            fprintf(file, "\n");
            fprintf(file, "extern const struct TilesInfo %s_tiles_info;\n", assetData->args->data_name.c_str());
            fprintf(file, "extern const struct MapInfo %s;\n", assetData->args->data_name.c_str());
        }
        else
        {
            fprintf(file, "#include \"MetaSpriteInfo.h\"\n");
            fprintf(file, "\n");
            fprintf(file, "extern const struct MetaSpriteInfo %s;\n", assetData->args->data_name.c_str());
        }
    }
    else
    {
        fprintf(file, "#define %s_TILE_ORIGIN %d\n", assetData->args->data_name.c_str(), assetData->args->tile_origin);
        fprintf(file, "#define %s_TILE_W %d\n", assetData->args->data_name.c_str(), assetData->image.tile_w);
        fprintf(file, "#define %s_TILE_H %d\n", assetData->args->data_name.c_str(), assetData->image.tile_h);
        fprintf(file, "#define %s_WIDTH %d\n", assetData->args->data_name.c_str(), (unsigned int)assetData->args->spriteSize.width);
        fprintf(file, "#define %s_HEIGHT %d\n", assetData->args->data_name.c_str(), (unsigned int)assetData->args->spriteSize.height);
        // The TILE_COUNT calc here is referring to number of 8x8 tiles,
        // so the >> 3 for each sizes axis is to get a multiplier for larger hardware sprites such as 8x16 and 16x16
        fprintf(file, "#define %s_TILE_COUNT %d\n", assetData->args->data_name.c_str(), ((unsigned int)export_tiles_count) * (assetData->image.tile_h >> 3) * (assetData->image.tile_w >> 3));
        if(assetData->args->include_palettes) {
            fprintf(file, "#define %s_PALETTE_COUNT %d\n", assetData->args->data_name.c_str(), (unsigned int)(assetData->image.total_color_count / assetData->image.colors_per_pal));
            fprintf(file, "#define %s_COLORS_PER_PALETTE %d\n", assetData->args->data_name.c_str(), (unsigned int)assetData->image.colors_per_pal);
            fprintf(file, "#define %s_TOTAL_COLORS %d\n", assetData->args->data_name.c_str(), (unsigned int)assetData->image.total_color_count);
        }

        if(assetData->args->includedMapOrMetaspriteData) {

            if(assetData->args->export_as_map)
            {
                fprintf(file, "#define %s_MAP_ATTRIBUTES ", assetData->args->data_name.c_str());
                if(assetData->args->use_map_attributes && assetData->map_attributes.size())
                    fprintf(file, "%s_map_attributes\n", assetData->args->data_name.c_str());
                else
                    fprintf(file, "0\n");

                if(assetData->args->use_map_attributes)
                {
                    int scale = assetData->args->use_2x2_map_attributes ? 2 : 1;
                    fprintf(file, "#define %s_MAP_ATTRIBUTES_WIDTH %d\n", assetData->args->data_name.c_str(), (int)(scale * assetData->args->map_attributes_size.width));
                    fprintf(file, "#define %s_MAP_ATTRIBUTES_HEIGHT %d\n", assetData->args->data_name.c_str(), (int)(scale * assetData->args->map_attributes_size.height));
                    fprintf(file, "#define %s_MAP_ATTRIBUTES_PACKED_WIDTH %d\n", assetData->args->data_name.c_str(), (int)assetData->args->map_attributes_packed_size.width);
                    fprintf(file, "#define %s_MAP_ATTRIBUTES_PACKED_HEIGHT %d\n", assetData->args->data_name.c_str(), (int)assetData->args->map_attributes_packed_size.height);
                }

                // TODO: FIXME: Based on above if statement, this code will never be reached if (assetData->args->use_structs) is true (despite being tested in code below)
                if(assetData->args->use_structs)
                {
                    fprintf(file, "#define %s_TILE_PALS ", assetData->args->data_name.c_str());
                    if(assetData->args->use_map_attributes)
                        fprintf(file, "0\n");
                    else
                        fprintf(file, "%s_tile_pals\n", assetData->args->data_name.c_str());
                }
            }
            else
            {
                fprintf(file, "#define %s_PIVOT_X %d\n", assetData->args->data_name.c_str(), assetData->args->pivot.x);
                fprintf(file, "#define %s_PIVOT_Y %d\n", assetData->args->data_name.c_str(), assetData->args->pivot.y);
                fprintf(file, "#define %s_PIVOT_W %d\n", assetData->args->data_name.c_str(), (unsigned int)assetData->args->pivot.width);
                fprintf(file, "#define %s_PIVOT_H %d\n", assetData->args->data_name.c_str(), (unsigned int)assetData->args->pivot.height);
            }
        }
        fprintf(file, "\n");
        fprintf(file, "BANKREF_EXTERN(%s)\n", assetData->args->data_name.c_str());
        fprintf(file, "\n");

        if (has_palette_data_to_export) {
            fprintf(file, "extern const palette_color_t %s_palettes[%d];\n", assetData->args->data_name.c_str(), (unsigned int)export_color_count);
        }
        if(assetData->args->includeTileData) {
            fprintf(file, "extern const uint8_t %s_tiles[%d];\n", assetData->args->data_name.c_str(), (unsigned int)(export_tiles_count * (assetData->image.tile_w * assetData->image.tile_h * assetData->args->bpp / 8)));
        }

        fprintf(file, "\n");
        if(assetData->args->includedMapOrMetaspriteData) {
            if(assetData->args->export_as_map)
            {
                fprintf(file, "extern const unsigned char %s_map[%d];\n", assetData->args->data_name.c_str(), (unsigned int)(assetData->map).size());

                if(assetData->args->use_map_attributes && assetData->map_attributes.size()) {
                    fprintf(file, "extern const unsigned char %s_map_attributes[%d];\n", assetData->args->data_name.c_str(), (unsigned int)(assetData->map_attributes).size());
                }
                else
                {
                    // Some platforms (like SMS/GG) encode attributes as part of map
                    // For compatibility, add a define that makes _map_attributes equal _map,
                    // so that set_bkg_attributes can work the same on these platforms
                    fprintf(file, "#define %s_map_attributes %s_map\n", assetData->args->data_name.c_str(), assetData->args->data_name.c_str());
                }
                // TODO: FIXME: Based on above if statement, this code will never be reached if (assetData->args->use_structs) is true (despite being tested in code below)
                if(!assetData->args->use_map_attributes && (assetData->args->includeTileData) && (assetData->args->use_structs)) {
                    fprintf(file, "extern const unsigned char* %s_tile_pals[%d];\n", assetData->args->data_name.c_str(), (unsigned int)(assetData->tiles).size());
                }
            }
            else
            {
                fprintf(file, "extern const metasprite_t* const %s_metasprites[%d];\n", assetData->args->data_name.c_str(), (unsigned int)(assetData->sprites.size()));
            }
        }
    }
    fprintf(file, "\n");
    fprintf(file, "#endif\n");


    fclose(file);
    // END: Output .h FILE

    return true; // success
}



bool export_c_file( PNG2AssetData* assetData) {

    FILE* file;
    calc_palette_and_tileset_export_size(assetData);

    file = fopen(assetData->args->output_filename.c_str(), "w");
    if(!file) {
        printf("Error writing file: %s", assetData->args->output_filename.c_str());
        return false;
    }

    if(assetData->args->bank >= 0) fprintf(file, "#pragma bank %d\n\n", assetData->args->bank);

    fprintf(file, "//AUTOGENERATED FILE FROM png2asset\n\n");

    fprintf(file, "#include <stdint.h>\n");
    fprintf(file, "#include <gbdk/platform.h>\n");
    fprintf(file, "#include <gbdk/metasprites.h>\n");
    fprintf(file, "\n");

    fprintf(file, "BANKREF(%s)\n\n", assetData->args->data_name.c_str());

    if (has_palette_data_to_export) {

        if (!(assetData->args->use_structs) || (assetData->args->includeTileData)) {
            fprintf(file, "const palette_color_t %s_palettes[%d] = {\n", assetData->args->data_name.c_str(), (unsigned int)export_color_count);
            for(size_t i = export_color_start / assetData->image.colors_per_pal; i < assetData->image.total_color_count / assetData->image.colors_per_pal; ++i)
            {
                if(i != 0)
                    fprintf(file, ",\n");
                fprintf(file, "\t");

                unsigned char* pal_ptr = &assetData->image.palette[i * (assetData->image.colors_per_pal * RGBA32_SZ)];
                for(int c = 0; c < (int)assetData->image.colors_per_pal; ++c, pal_ptr += RGBA32_SZ)
                {
                    size_t rgb222 = (((pal_ptr[2] >> 6) & 0x3) << 4) |
                        (((pal_ptr[1] >> 6) & 0x3) << 2) |
                        (((pal_ptr[0] >> 6) & 0x3) << 0);
                    if(assetData->args->convert_rgb_to_nes) {
                        fprintf(file, "0x%0X", rgb_to_nes[rgb222]);
                    }
                    else
                        fprintf(file, "RGB8(%3d,%3d,%3d)", pal_ptr[0], pal_ptr[1], pal_ptr[2]);
                    if(c != (int)assetData->image.colors_per_pal - 1)
                        fprintf(file, ", ");
                    // Line break every 4 color entries, to keep line width down
                    if(((c + 1) % 4) == 0)
                        fprintf(file, "\n\t");
                }
            }
            fprintf(file, "\n};\n");
        }
    }

    if(assetData->args->includeTileData) {
        fprintf(file, "\n");
        fprintf(file, "const uint8_t %s_tiles[%d] = {\n", assetData->args->data_name.c_str(), (unsigned int)(export_tiles_count * assetData->image.tile_w * assetData->image.tile_h * assetData->args->bpp / 8));
        fprintf(file, "\t");
        for(vector< Tile >::iterator it = assetData->tiles.begin() + export_tiles_start; it != assetData->tiles.end(); ++it)
        {

            int line_break = 1; // Start with 1 to prevent line break on first iteration
            vector< unsigned char > packed_data = (*it).GetPackedData(assetData->args->pack_mode, assetData->image.tile_w, assetData->image.tile_h, assetData->args->bpp);
            for(vector< unsigned char >::iterator it2 = packed_data.begin(); it2 != packed_data.end(); ++it2)
            {
                fprintf(file, "0x%02x", (*it2));
                if((it + 1) != assetData->tiles.end() || (it2 + 1) != packed_data.end())
                    fprintf(file, ",");
                // Add a line break after each 8x8 tile
                if(((line_break++) % (8 / assetData->args->bpp)) == 0)
                    fprintf(file, "\n\t");
            }

            if((!assetData->args->export_as_map) && (it != assetData->tiles.end()))
                fprintf(file, "\n");
        }
        fprintf(file, "};\n\n");
    }

    if(assetData->args->includedMapOrMetaspriteData) {

        if(!assetData->args->export_as_map)
        {
            for(vector< MetaSprite >::iterator it = assetData->sprites.begin(); it != assetData->sprites.end(); ++it)
            {
                fprintf(file, "const metasprite_t %s_metasprite%d[] = {\n", assetData->args->data_name.c_str(), (int)(it - assetData->sprites.begin()));
                for(MetaSprite::iterator it2 = (*it).begin(); it2 != (*it).end(); ++it2)
                {
                    int pal_idx  = (*it2).props & 0xF;
                    int dmg_pal  = ((*it2).props >> 4) & 1;
                    int flip_x   = ((*it2).props >> 5) & 1;
                    int flip_y   = ((*it2).props >> 6) & 1;
                    int priority = ((*it2).props >> 7) & 1;
                    fprintf(file,
                        "\tMETASPR_ITEM(%d, %d, %d, S_PAL(%d)%s%s%s%s),\n",
                        (*it2).offset_y,
                        (*it2).offset_x,
                        (*it2).offset_idx,
                        pal_idx,
			(dmg_pal)  ? " | S_PALETTE" : "",
                        (flip_x)   ? " | S_FLIPX" : "",
                        (flip_y)   ? " | S_FLIPY" : "",
                        (priority) ? " | S_PRIORITY" : "");
                }
                fprintf(file, "\tMETASPR_TERM\n");
                fprintf(file, "};\n\n");
            }

            fprintf(file, "const metasprite_t* const %s_metasprites[%d] = {\n\t", assetData->args->data_name.c_str(), (unsigned int)(assetData->sprites.size()));
            for(vector< MetaSprite >::iterator it = assetData->sprites.begin(); it != assetData->sprites.end(); ++it)
            {
                fprintf(file, "%s_metasprite%d", assetData->args->data_name.c_str(), (int)(it - assetData->sprites.begin()));
                if(it + 1 != assetData->sprites.end())
                    fprintf(file, ", ");
            }
            fprintf(file, "\n};\n");

            if(assetData->args->use_structs)
            {
                fprintf(file, "\n");
                fprintf(file, "#include \"MetaSpriteInfo.h\"\n");
                fprintf(file, "const struct MetaSpriteInfo %s = {\n", assetData->args->data_name.c_str());
                fprintf(file, "\t%d, //width\n", (unsigned int)assetData->args->pivot.width);
                fprintf(file, "\t%d, //height\n", (unsigned int)assetData->args->pivot.height);
                fprintf(file, "\t%d, //num tiles\n", (unsigned int)assetData->tiles.size() * (assetData->image.tile_h >> 3));
                fprintf(file, "\t%s_tiles, //tiles\n", assetData->args->data_name.c_str());
                fprintf(file, "\t%d, //num palettes\n", (unsigned int)(assetData->image.total_color_count / assetData->image.colors_per_pal));
                fprintf(file, "\t%s_palettes, //CGB palette\n", assetData->args->data_name.c_str());
                fprintf(file, "\t%d, //num sprites\n", (unsigned int)assetData->sprites.size());
                fprintf(file, "\t%s_metasprites, //metasprites\n", assetData->args->data_name.c_str());
                fprintf(file, "};\n");
            }
        }
        else
        {
            if(assetData->args->includeTileData) {
                if(assetData->args->use_structs)
                {
                    //Export tiles pals (if any)
                    if(!assetData->args->use_map_attributes)
                    {
                        fprintf(file, "\n");
                        fprintf(file, "const uint8_t %s_tile_pals[%d] = {\n\t", assetData->args->data_name.c_str(), (unsigned int)export_tiles_count);
                        for(vector< Tile >::iterator it = assetData->tiles.begin() + export_tiles_start; it != assetData->tiles.end(); ++it)
                        {
                            if(it != assetData->tiles.begin())
                                fprintf(file, ", ");
                            fprintf(file, "%d", it->pal);
                        }
                        fprintf(file, "\n};\n");
                    }
                    //Export Tiles Info
                    fprintf(file, "\n");
                    fprintf(file, "#include \"TilesInfo.h\"\n");
                    fprintf(file, "BANKREF(%s_tiles_info)\n", assetData->args->data_name.c_str());
                    fprintf(file, "const struct TilesInfo %s_tiles_info = {\n", assetData->args->data_name.c_str());
                    fprintf(file, "\t.num_frames=%d, //num tiles\n", (unsigned int)assetData->tiles.size() * (assetData->image.tile_h >> 3));
                    fprintf(file, "\t.data=%s_tiles, //tiles\n", assetData->args->data_name.c_str());
                    fprintf(file, "\t.num_pals=%d, //num palettes\n", (unsigned int)(assetData->image.total_color_count / assetData->image.colors_per_pal));
                    fprintf(file, "\t.pals=%s_palettes, //palettes\n", assetData->args->data_name.c_str());
                    if(!assetData->args->use_map_attributes)
                        fprintf(file, "\t.color_data=%s_tile_pals, //tile palettes\n", assetData->args->data_name.c_str());
                    else
                        fprintf(file, "\t.color_data=0 //tile palettes\n");
                    fprintf(file, "};\n");
                }
            } else {
                if((assetData->args->use_structs) && (assetData->args->source_tilesets.size())) {
                    fprintf(file, "\n");
                    fprintf(file, "#include \"TilesInfo.h\"\n");
                    fprintf(file, "extern const void __bank_%s;\n", extract_name(assetData->args->source_tilesets[0]).c_str());
                    fprintf(file, "extern const struct TilesInfo %s;\n", extract_name(assetData->args->source_tilesets[0]).c_str());
                }
            }

            //Export map
            fprintf(file, "\n");
            fprintf(file, "const unsigned char %s_map[%d] = {\n", assetData->args->data_name.c_str(), (unsigned int)(assetData->map.size()));
            // TODO: These hardwired "/ 8" should be using " / assetData->image.tile_w" and "_h"
            // TODO: Should also be converted to using args.map_entry_size_bytes
            size_t line_size = assetData->map.size() / (assetData->image.h / 8);
            if(assetData->args->output_transposed) {

                for(size_t i = 0; i < line_size; ++i)
                {
                    fprintf(file, "\t");
                    for(size_t j = 0; j < assetData->image.h / 8; ++j)
                    {
                        fprintf(file, "0x%02x,", assetData->map[j * line_size + i]);
                    }
                    fprintf(file, "\n");
                }
            }
            else {

                for(size_t j = 0; j < assetData->image.h / 8; ++j)
                {
                    fprintf(file, "\t");
                    for(size_t i = 0; i < line_size; ++i)
                    {
                        fprintf(file, "0x%02x,", assetData->map[j * line_size + i]);
                    }
                    fprintf(file, "\n");
                }
            }
            fprintf(file, "};\n");


            //Export map attributes (if any)
            if(assetData->args->use_map_attributes && assetData->map_attributes.size())
            {
                fprintf(file, "\n");
                fprintf(file, "const unsigned char %s_map_attributes[%d] = {\n", assetData->args->data_name.c_str(), (unsigned int)(assetData->map_attributes.size()));
                if(assetData->args->output_transposed) {
                    for(size_t i = 0; i < assetData->args->map_attributes_packed_size.width; ++i)
                    {
                        fprintf(file, "\t");
                        for(size_t j = 0; j < assetData->args->map_attributes_packed_size.height; ++j)
                        {
                            fprintf(file, "0x%02x,", assetData->map_attributes[j * assetData->args->map_attributes_packed_size.width + i]);
                        }
                        fprintf(file, "\n");
                    }
                }
                else {
                    for(size_t j = 0; j < assetData->args->map_attributes_packed_size.height; ++j)
                    {
                        fprintf(file, "\t");
                        for(size_t i = 0; i < assetData->args->map_attributes_packed_size.width; ++i)
                        {
                            fprintf(file, "0x%02x,", assetData->map_attributes[j * assetData->args->map_attributes_packed_size.width + i]);
                        }
                        fprintf(file, "\n");
                    }
                }

                fprintf(file, "};\n");
            }

            if(assetData->args->use_structs)
            {
                //Export Map Info
                fprintf(file, "\n");
                fprintf(file, "#include \"MapInfo.h\"\n");
                if(assetData->args->includeTileData) {
                    fprintf(file, "BANKREF_EXTERN(%s_tiles_info)\n", assetData->args->data_name.c_str());
                }
                fprintf(file, "const struct MapInfo %s = {\n", assetData->args->data_name.c_str());
                fprintf(file, "\t.data=%s_map, //map\n", assetData->args->data_name.c_str());
                fprintf(file, "\t.width=%d, //with\n", assetData->image.w >> 3);
                fprintf(file, "\t.height=%d, //height\n", assetData->image.h >> 3);
                if(assetData->args->use_map_attributes && assetData->map_attributes.size())
                    fprintf(file, "\t.attributes=%s_map_attributes, //map attributes\n", assetData->args->data_name.c_str());
                else
                    fprintf(file, "\t.attributes=0, //map attributes\n");

                if(assetData->args->includeTileData) {
                    fprintf(file, "\t.tiles_bank=BANK(%s_tiles_info), //tiles bank\n", assetData->args->data_name.c_str());
                    fprintf(file, "\t.tiles=&%s_tiles_info, //tiles info\n", assetData->args->data_name.c_str());
                } else {
                    if (assetData->args->source_tilesets.size()) {
                        fprintf(file, "\t.tiles_bank=BANK(%s), //tiles bank\n", extract_name(assetData->args->source_tilesets[0]).c_str());
                        fprintf(file, "\t.tiles=&%s, //tiles info\n", extract_name(assetData->args->source_tilesets[0]).c_str());
                    }
                }
                fprintf(file, "};\n");
            }
        }
    } else {
        // "-use_structs -tiles_only" case
        if(assetData->args->includeTileData) {
            if(assetData->args->use_structs)
            {
                //Export tiles pals (if any)
                if(!assetData->args->use_map_attributes)
                {
                    fprintf(file, "\n");
                    fprintf(file, "const uint8_t %s_tile_pals[%d] = {\n\t", assetData->args->data_name.c_str(), (unsigned int)export_tiles_count);
                    for(vector< Tile >::iterator it = assetData->tiles.begin() + export_tiles_start; it != assetData->tiles.end(); ++it)
                    {
                        if(it != assetData->tiles.begin())
                            fprintf(file, ", ");
                        fprintf(file, "%d", it->pal);
                    }
                    fprintf(file, "\n};\n");
                }
                //Export Tiles Info
                fprintf(file, "\n");
                fprintf(file, "#include \"TilesInfo.h\"\n");
                fprintf(file, "const struct TilesInfo %s = {\n", assetData->args->data_name.c_str());
                fprintf(file, "\t.num_frames=%d, //num tiles\n", (unsigned int)assetData->tiles.size() * (assetData->image.tile_h >> 3));
                fprintf(file, "\t.data=%s_tiles, //tiles\n", assetData->args->data_name.c_str());
                fprintf(file, "\t.num_pals=%d, //num palettes\n", (unsigned int)(assetData->image.total_color_count / assetData->image.colors_per_pal));
                fprintf(file, "\t.pals=%s_palettes, //palettes\n", assetData->args->data_name.c_str());
                if(!assetData->args->use_map_attributes)
                    fprintf(file, "\t.color_data=%s_tile_pals, //tile palettes\n", assetData->args->data_name.c_str());
                else
                    fprintf(file, "\t.color_data=0 //tile palettes\n");
                fprintf(file, "};\n");
            }
        }            
    }

    fclose(file);

    return true; // success
}


bool export_map_binary( PNG2AssetData* assetData) {

    std::ofstream mapBinaryFile, mapAttributesBinaryfile, tilesBinaryFile;
    calc_palette_and_tileset_export_size(assetData);

    if (assetData->args->includeTileData) {
        tilesBinaryFile.open(assetData->args->output_filename_tiles_bin, std::ios_base::binary);

        for(vector< Tile >::iterator it = assetData->tiles.begin() + export_tiles_start; it != assetData->tiles.end(); ++it)
        {

            vector< unsigned char > packed_data = (*it).GetPackedData(assetData->args->pack_mode, assetData->image.tile_w, assetData->image.tile_h, assetData->args->bpp);
            for(vector< unsigned char >::iterator it2 = packed_data.begin(); it2 != packed_data.end(); ++it2)
            {

                const char chars[] = { (const char)(*it2) };
                tilesBinaryFile.write(chars, 1);
            }

        }
        // Finalize the files
        tilesBinaryFile.close();
    }

    if (assetData->args->includedMapOrMetaspriteData) {
        mapBinaryFile.open(assetData->args->output_filename_bin, std::ios_base::binary);

        // Open our file for writing attributes if specified
        if (assetData->args->use_map_attributes && assetData->map_attributes.size()) {
            mapAttributesBinaryfile.open(assetData->args->output_filename_attributes_bin, std::ios_base::binary);
        }

        int columns = assetData->image.w >> 3;
        int rows = assetData->image.h >> 3;

        // If we want the values to be column-by-column
        if(assetData->args->output_transposed) {

            int map_entry_size = assetData->args->map_entry_size_bytes;
            // Swap the column/row for loops
            for(int column = 0; column < columns; column++) {
                for(int row = 0; row < rows; ++row) {

                    int tile = (column + row * columns) * map_entry_size;

                    // Write map items column-by-column
                    mapBinaryFile.write( (const char *) &(assetData->map[tile]), map_entry_size);

                    if (assetData->args->use_map_attributes && assetData->map_attributes.size()) {
                       mapAttributesBinaryfile.write( (const char*) &(assetData->map_attributes[tile]), map_entry_size);
                    }
                }
            }
        }
        else {
            // Write the arrays as-is, row-by-row
            mapBinaryFile.write((const char*)(&assetData->map[0]), assetData->map.size());

            if (assetData->args->use_map_attributes && assetData->map_attributes.size()) {
                mapAttributesBinaryfile.write((const char*)(&assetData->map_attributes[0]), assetData->map_attributes.size());
            }
        }
        // Finalize the files
        mapBinaryFile.close();
        if (assetData->args->use_map_attributes && assetData->map_attributes.size()) {
            mapAttributesBinaryfile.close();
        }
    }


    return true; // success
}
